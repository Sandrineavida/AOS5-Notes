
**第6章**  
**大规模线性规划**  

大规模线性规划是指由大量决策变量（约束矩阵的列）和/或约束条件（约束矩阵的行）组成的线性规划问题。在实际应用中，许多有趣的应用由于包含过多的约束或变量而导致问题变得更加复杂。这可能导致内存空间问题和/或计算时间过长。此外，某些涉及不确定性的情况可能通过此类形式来表示。这可能对应于一些无法明确列出的潜在情况的约束，且模型中可能并不总能预测这些约束。在本章中，我们将通过实际例子来说明两种情况，并介绍解决这些问题的方法。  

这些方法遵循一个简单的原则：如果约束条件（或变量）过多，我们会通过***解决部分约束问题***，并根据需要生成其他约束条件（或变量）。我们通过解决所谓的***分离/定价***问题来实现这一点。

首先，我们介绍***约束生成算法***，它通过***解决所谓的分离问题来生成新的约束***——这是第一节的重点。

同样地，如果列过多，我们会通过解决部分列问题并根据需要生成列来解决问题。这就是所谓的列生成算法。

在本章最后，我们将讨论Benders分解算法，这将引导我们探索另一种更复杂的约束生成算法。  

### 6.1 约束生成  
让我们考虑一个优化线性规划问题。约束生成算法的工作原理如下：  

1. 初始化（简化的）主问题 $\max Cx$，满足 $A'x = b$，$x \geq 0$，其中 $A'$ 代表约束 $Ax = b$ 的一小部分子集。  
2. 求解与主问题相关的线性规划并获得当前解 $x$。
3. 如果 $x$ 满足所有约束条件 $Ax = b$，则停止（当前解是最优解）；否则将一个（或多个）违反的约束条件加入 $A'x = b$ 并返回步骤2。

该方法非常简单：仅在需要时添加约束条件。关键部分是***第3步***，即所谓的***分离问题***，在这里我们希望添加一个违反的约束条件（或证明不存在这样的约束）。如果约束的数量非常多，我们无法显式枚举所有的约束并逐一检查。
因此，我们需要*将分离问题表述为一个线性规划（LP）问题，更可能是一个整数线性规划（ILP）问题*。

上述算法可以通过旅行商问题（TSP）来说明。令 $G = (V, E)$ 为一个图，其中包含 $n$ 个节点（$V$，表示城市）和弧（$E$，表示城市间的直接连接），这些弧的权重由它们的距离 $d_{ij}$ 表示。令 $x_{ij}$ 为决策变量，当弧 $(ij)$ 被选为回路的一部分时取值为1，否则为0。问题可以表述如下：

$$
\min \sum_{i,j} d_{ij}x_{ij} \tag{6.1a}
$$

**约束条件：**

$$
\sum_{j=1}^n x_{ij} = 1, \quad \forall i = 1, 2, \ldots, n \tag{6.1b}
$$

$$
\sum_{i=1}^n x_{ij} = 1, \quad \forall j = 1, 2, \ldots, n \tag{6.1c}
$$

$$
\sum_{i \in S, j \in V \setminus S} x_{ij} \geq 1, \quad \forall S \subset V \tag{6.1d}
$$

$$
x_{ij} \in \{0, 1\}, \quad \forall i = 1, 2, \ldots, n, \, j = 1, 2, \ldots, n \tag{6.1e}
$$

显然，约束条件 (6.1d) 非常多(有$2^n$个)，无法全部显式列出。

因此，根据上述算法，***初始的（简化的）主问题不包含 (6.1d) 中的任何约束条件***。

获得的解 $x$ 必然由若干***回路***组成，且***所有节点都被访问***。

如果解对应于**单一回路**，则解是**最优**的；

否则，可以通过在子回路中加入一组 $S$ 中的所有节点来构建类型 (6.1d) 的约束。

(即，如果无法构建串联了所有节点的回路，那就通过添加**一次**条件(6.1d)来串联所有节点。)

上述例子非常简单。主要的困难在于如何表述问题。本章最后一节中，我们将探讨一些更复杂的方法来生成约束/切割。检查哪些节点包含在子回路中可以通过多项式时间完成，具体方法是从随机节点开始，沿着具有 $x_{ij} = 1$ 的弧构建子回路，直到返回到起始节点为止。访问到的节点形成集合 $S$。

---

> “否则，可以通过在子回路中加入一组 $S$ 中的所有节点来构建类型 (6.1d) 的约束。”：

在旅行商问题（TSP）或类似问题中，如果当前解 \(x\) 并未满足所有 \(6.1d\) 类型的约束（即未能形成一个完整的单一回路），解通常会包含多个子回路（sub-tours）。此时，需要通过以下方式修正解，以确保符合问题的约束条件：

```
一开始会有子回路的核心原因是：

    初始问题缺少所有 6.1d 约束，导致解不强制成为单一回路。
```

### 子回路问题的解释
- **什么是子回路？**
  - 子回路是指 \(x\) 中的一部分路径，它形成了一个回路，但并未将所有节点都包括在内。
  - 例如，如果有 6 个城市，但解只形成了两个小回路，一个回路是 \(A \to B \to C \to A\)，另一个是 \(D \to E \to F \to D\)，这就不满足完整回路的要求。

- **类型 (6.1d) 约束的作用**
  - 类型 (6.1d) 的约束：

    $$
    \sum_{i \in S, j \in V \setminus S} x_{ij} \geq 1, \quad \forall S \subset V
    $$

    保证了在图中从一个子集 \(S\) 到其补集 \(V \setminus S\) 至少有一条边。换句话说，这个约束迫使解必须将所有节点连接在一个整体回路中。

### 通过加入约束来修正子回路问题
如果当前解 \(x\) 包含子回路（即解不满足单一回路的要求），可以通过以下方式修正：
1. **找到子回路对应的集合 \(S\)**：
   - 对每个子回路，标记出包含的节点集合 \(S\)。
   - 例如，子回路 \(A \to B \to C \to A\) 对应集合 \(S = \{A, B, C\}\)。

2. **构造新的约束**：
   - 将 \(S\) 中的所有节点与 \(V \setminus S\) 中的所有节点（即不在子回路中的节点）连接起来。
   - 这对应于添加约束：

     $$
     \sum_{i \in S, j \in V \setminus S} x_{ij} \geq 1
     $$

   - 该约束强制要求子回路 \(S\) 必须通过至少一条边连接到图中其他节点，从而破坏子回路并逐渐形成完整回路。

3. **更新主问题并重新求解**：
   - 将新的约束添加到主问题中，再次求解，直到解中不再包含子回路（即所有节点都连接成一个完整的单一回路）。

### 举例说明
假设有 6 个节点 $A, B, C, D, E, F$，当前解形成了两个子回路：
1. 子回路 1：$A \to B \to C \to A$，对应集合 $S_1 = \{A, B, C\}$。
2. 子回路 2：$D \to E \to F \to D$，对应集合 $S_2 = \{D, E, F\}$。

要解决这个问题：
1. 对于子回路 1，添加约束：
   $$
   \sum_{i \in \{A, B, C\}, j \in \{D, E, F\}} x_{ij} \geq 1
   $$

   这意味着必须在 \(A, B, C\) 和 \(D, E, F\) 之间添加至少一条边。

2. 对子回路 2 也进行类似处理。

### 目的
通过动态生成约束（如上述方式），逐步修正解，使得所有子回路被打破，最终形成一个满足单一回路的最优解。

### 总结
这句话的核心意思是：**当解中存在子回路时，通过识别子回路的节点集合 \(S\)，构造新的类型 (6.1d) 约束，将这些子回路强制连接到其他节点，从而消除子回路问题，确保解符合完整回路的要求。**

---
约束条件 \(6.1d\) 是：

$$
\sum_{i \in S, j \in V \setminus S} x_{ij} \geq 1, \quad \forall S \subset V.
$$

### 分析：
- 约束条件 \(6.1d\) 的数量取决于子集 $S \subset V$ 的数量，其中 $V$ 是节点的集合。
- 对于一个包含 $n$ 个节点的图，集合 $V$ 的所有可能子集数量为 $2^n$。
- 然而，排除空集 $S = \emptyset$ 和 $S = V$（因为这些子集不会生成有意义的约束），实际约束的数量为：

$$
\text{数量} = 2^n - 2.
$$

### 具体例子：
如果图中有 $n = 5$ 个节点：
- 子集总数为 $2^5 = 32$。
- 去掉空集和整个集合的两个子集，约束数量为 $32 - 2 = 30$。

如果图中有 $n = 10$ 个节点：
- 子集总数为 $2^{10} = 1024$。
- 约束数量为 $1024 - 2 = 1022$。

### 结论：
对于节点数为 $n$ 的图，约束条件 \(6.1d\) 的总数量为：
$$
2^n - 2.
$$

由于数量随 $n$ 指数级增长，当 $n$ 较大时，这个约束条件的数量会变得极其庞大，因此不能显式列出所有的约束，通常需要使用分离问题（Separation Problem）动态生成约束。

---

### 6.2 列生成

该方法最初由 Ford 和 Fulkerson 于1958年提出。从形式上来说，列生成是一种通过在单纯形方法（Simplex）的定价阶段添加列（即变量）来解决线性规划问题的方法。

Formally,
 column generation is a way of solving a linear programming problem that adds  columns (i.e. variables) during the $pricing \space phase^2$ of the simplex method of solv
ing the problem. 

*2 Pricing phase corresponds to the phase when the Simplex algorithm looks for the new
 column to be added in the basis.


在这一背景下，许多研究人员发现列生成是一种非常强大的技术，可用于解决广泛的工业问题，并达到最优或接近最优的结果。在众多应用中，Gilmore 和 Gomory 在解决切割库存问题中展示了它的有效性。

列生成的核心思想是，单纯形方法（Simplex）并不需要同时访问问题的所有变量。事实上，列生成的主要优势在于，不需要将所有变量都包含在公式中（与约束生成算法的原则相同）。相反，问题首先被表述为一个包含少量变量的受限主问题，并在需要时引入新的变量。这种方法与单纯形方法的工作原理一致，这意味着如果可以找到具有正（或负）简化成本的列用于最大化（或最小化）问题，那么将该列添加到主问题中，并重复该过程，直到无法添加新的列为止。因此，待解决的问题是最大化（或最小化）简化成本函数，因为在最大化问题中，只有具有正简化成本的列才会被引入基，因此需要检查是否有任何列具有正值。

---

单纯形方法（Simplex）的基本思想

单纯形方法是一种基于迭代的算法，通过在可行解的顶点之间移动来寻找最优解。

    几何解释：
        线性规划问题的解存在于约束条件定义的凸多面体的边界上。
        单纯形方法从一个顶点（可行解）开始，逐步沿着多面体的边移动到下一个更优的顶点，直到到达最优解。

    代数解释：
        在数学上，每个顶点对应一个约束子集的基础解（Basic Solution）。
        单纯形方法通过变量的替换来在不同的基础解之间切换，确保每一步目标函数值都增加（或减少）。

---

#### 6.2.1 算法

让我们考虑一个优化线性规划问题。从形式上看，与约束生成的思路相同，列生成算法的步骤如下：

1. 从一部分列开始，构建主问题。

2. 求解主问题，并识别与主问题约束对应的对偶系数。

3. 编写列生成算法：将潜在列的组成部分作为变量，将在步骤1中找到的对偶系数作为参数，写出一个线性规划问题，其目标函数是列的简化成本，约束条件是变量必须满足以构成一个有效的列。解决该问题。

4. 如果上述问题（步骤3）找到具有正（或负）简化成本的列用于最大化（或最小化）问题，则通过添加新列更新主问题并返回步骤2；否则当前解是最优解。

---

### 6.2.2 示例：切割库存问题

[一个很好的讲解](https://mp.weixin.qq.com/s?__biz=MzU2NDc1MTE3Mg==&mid=2247484818&idx=1&sn=a0df897d38ab32aab90a887843bcec9a&chksm=fc477bb9cb30f2af5a5d49a60f3b7ead6aa7894408e69c9cfb40bf139825f1814a41950bd3e4&mpshare=1&scene=1&srcid=0306pnDBakAONycdIvGwNjNy&sharer_sharetime=1583459820126&sharer_shareid=d35bcdb72469247fcdeeffa03109c5d9&key=ecd68b1e14854e41e7a4cf0987af0192b039d026cac21000ededcfa059241870c1e6af8764d6c5d6f98ee30a6cd365b8f08ebd29dab569f7cca88daac12535532fdf963624e58809b3d4e1ff5bce0af1&ascene=1&uin=ODc3NDIwMDYx&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AdF6khzoorXuytqFknByE44%3D&pass_ticket=n%2FCOw4N09sbYiPVW0uxYirvz%2FBI7F5DDpGW14TVNVlPG7iaxK6eI1%2B%2BbyWjNAClC)

我们有一个长度固定的卷材（数量假定无限），以及需求中需要切割成不同长度的小卷材。我们需要设计一种切割方法，既满足客户需求，又将浪费降到最低。小卷材是通过以特定方式切割大卷材获得的，这种切割方式被称为“切割模式”。

**示例：** 一个宽度为 $L=70$ 的大卷材可以被切割为三个宽度为 $l_1=17$ 的卷材和一个宽度为 $l_2=15$ 的卷材，浪费为4；这就构成了一种切割模式。传统的整数规划表述是通过最小化切割的卷材数量来满足需求约束，同时考虑整体尺寸约束。首先从一个整数线性规划（ILP）公式开始。

---

**ILP 表述：**

1. **定义变量：**
   - 令 \(N\) 表示可用卷材的索引。
   - \(y_n = 1\)：如果切割了卷材 \(n\)；否则 \(y_n = 0\)。
   - \(x_i^n\)：表示第 \(i\) 种需求在卷材 \(n\) 上切割的次数。
   - \(b_i\)：需求量（第 \(i\) 种小卷材的总需求）。

2. **优化目标：**
   - 最小化切割的大卷材数量：
     $$
     \min \sum_{n \in N} y_n
     $$

3. **约束条件：**
   - **满足需求：**  
     每种需求 \(i\) 的总切割量不小于需求量：
     $$
     \sum_{n \in N} x_i^n \geq b_i, \quad i = 1, 2, \dots, m.
     $$
   - **卷材宽度限制：**  
     每个卷材上切割的小卷材总宽度不能超过卷材宽度：
     $$
     \sum_{i=1}^m l_i x_i^n \leq L y_n, \quad n \in N.
     $$
   - **变量约束：**  
     $$
     x_i^n \geq 0, \, 整数; \quad y_n \in \{0, 1\}.
     $$

---

### 效率问题及列生成方法的应用

传统的 ILP 表述效率较低：
1. **对称解问题：** 因为可能存在许多对称解，这会使分支定界法难以处理。
2. **变量数量庞大：** 即使去掉完整性约束（连续松弛版本），变量数量仍然很大。

**列生成方法的优势：**
- **减少变量数量：** 列生成方法通过限制枚举的列数（切割模式）快速解决问题。
- **动态添加列：** 只在需要时生成新列，而不是显式列出所有可能模式。

---

**列生成的数学表述：**

1. **目标函数：**
   - 最小化使用的切割模式数量：
     $$
     \min \sum_{j=1}^n x_j
     $$
   - 其中，\(x_j\) 是模式 \(j\) 的使用次数。

2. **约束条件：**
   - **满足需求：**
     $$
     \sum_{j=1}^n a_{ij} x_j \geq b_i, \quad i = 1, 2, \dots, m,
     $$
     其中 \(a_{ij}\) 表示模式 \(j\) 中第 \(i\) 种需求的切割次数。

   - **非负性：**
     $$
     x_j \geq 0, \, 整数, \, j = 1, 2, \dots, n.
     $$

---

**动态生成切割模式（列）的步骤：**

1. **初始解：** 使用简单模式（例如将卷材切割为尽可能多的宽度 \(l_i\) 的卷材）形成一个基本解。

2. **计算简化成本：** 对于每个模式 \(j\)，计算简化成本：
   $$
   1 - \sum_{j=1}^m \pi_j z_j,
   $$
   其中 \(\pi_j\) 是对偶变量，表示当前需求的“影子价格”。

3. **生成新模式：** 如果存在负的简化成本，表示新模式可以改进当前解：
   - 解一个背包问题来确定新模式：
     $$
     \max \sum_{j=1}^m \pi_j z_j, \quad \text{s.t. } \sum_{j=1}^m l_j z_j \leq L.
     $$

4. **更新问题并迭代：** 将新模式加入模型，重新求解，直到没有负的简化成本。

---

### 注释

上述方法解决了连续版本的切割库存问题（卷材数量不必是整数），通常通过后续优化程序获得近似最优解。列生成方法特别适用于解决连续的大规模规划问题，因为它动态使用对偶变量，不需要显式列出所有可能列。

---

### 6.2.3 另一个示例：路径生成

问题如下：考虑一个由一组节点 $V$ 和一组带有给定容量 $C_e \, (e \in E)$ 的链路组成的网络，以及一个连接（或需求） $d$。  
对于连接 $d$，在其起始节点 $s_d$ 和终止节点 $t_d$ 之间定义了一组预定义路径集 $P_d$。任意路径 $p$ 可用它经过的链路集合 $p \subseteq E$ 来表示。

令 $x_p$ 表示分配到路径 $p \in P_d$ 的流量。我们需要找到一个可行流，其目标是最大化 $\sum_{p \in P_d} x_p$。换句话说，这就是通过路径变量而非流量变量表述的最大流问题。显然，如果将所有可能路径都包含进来，这两种表述是等价的。

在流理论中众所周知，任意非负的 $s-t$ 流可以分解为至多 $|E|$ 个流，其中每个是路径流或环流。我们只考虑路径流，因为环流不会增加流量的值。因此，思想是先通过给定路径集 $P_d$ 求解问题，并通过计算不在 $P_d$ 中其他路径的简化成本来检查其最优性。如果存在一条简化成本为负的路径，则将其添加到 $P_d$ 中，并迭代解决问题，直到达到最优解。上述列生成算法用于构建候选路径以加入集合 $P_d$。

**完整表述**（使用受限路径集）如下：

$$
\max \sum_{p \in P_d} x_p \tag{6.5a}
$$

**约束条件：**

$$
\sum_{p \in P_d, e \in p} x_p \leq C_e, \quad \forall e \in E \, (\pi_e) \tag{6.5b}
$$

$$
x_p \geq 0, \quad p \in P_d \tag{6.5c}
$$

其中，$\pi_e$ 是对偶变量。

**注释：**
- 对于最优基 $B$，对偶变量的表达式为 $C_B B^{-1}$，而简化成本的表达式为 $C_D - C_B B^{-1} D$，其中 $D$ 收集了基以外的列。  
- 我们注意到目标函数中，每条路径的成本向量 $C$ 都为1，而矩阵 $B$ 和 $D$ 的列由 $|E|$ 大小的向量组成，每行 $e$ 表示路径中经过链路 $e$ 的路径。

对于给定路径 $q \in D$，标量乘积 $q \pi$ 的值 $\sum_{e \in q} \pi_e$ 用于检查解的最优性。我们关注一个最大化问题，需要确保只有简化成本非正的列会被引入基。

---

**算法与切割库存问题类似：**

1. **初始化主问题：** 使用一组连接 $s_d$ 和 $t_d$ 的路径作为起点。  
2. **求解主问题：** 得到对偶变量 $\pi$ 的值。  
3. **计算最短路径 $q$：** 在权重为 $\pi$ 的图中找到最短路径。  
4. **检查简化成本：** 若简化成本 $r_q = 1 - \sum_{e \in q} \pi_e \geq 0$，则停止（解为最优解）；否则将路径 $q$ 添加到公式中并返回步骤2。

以下是图片内容的翻译：

---

### 6.3 练习

**练习 1：约束生成**

在图论的数学学科中，Menger定理指出，在有限图中，最小割集的大小等于任意两点之间可找到的最大边独立路径数。此定理由Karl Menger于1927年提出，表征了图的连通性，并由最大流最小割定理推广而来。

**边连通版本的Menger定理**如下：  
设 $G=(X, U)$ 是一个有限无向图，$x$ 和 $y$ 是两个不同的顶点。则最小边割集的大小（从 $x$ 到 $y$ 的所有边独立路径中移除导致 $x$ 和 $y$ 不连通的最小边数）等于从 $x$ 到 $y$ 的最大成对边独立路径数。

**推广到所有点对：** 若图是 $k$-边连通的（即在移除少于 $k$ 条边后仍然连通），当且仅当每一对顶点之间具有 $k$ 条边独立路径。

我们下面关注的是 **2-边连通网络**（称为双连通）。以下线性规划的目标是计算最小成本双连通网络。假设任意链路 $(i, j)$ 可开放，且具有某成本 $w_{i,j}$。给定一组节点，需要决定哪些链路应被加入网络，以便网络在任意一条链路被移除时仍然连通，同时使网络的总体链路成本最小化。

**目标函数：**

$$
\min \sum_{(i,j) \in U} w_{i,j} x_{i,j}
$$

**约束条件：**

$$
\sum_{i \in S} \sum_{j \in V \setminus S} x_{i,j} \geq 2, \quad \forall S \subset V
$$

$$
x_{i,j} \in \{0, 1\}, \quad (i, j) \in U
$$

决策变量由向量 $x$ 表示，其中 $x_{i,j} = 1$ 表示弧 $(i, j)$ 被选择，$0$ 则表示未被选择。上述二元线性规划包含大量约束，并提出了一个割/约束生成算法。设计该算法时，应首先研究分离问题。因此，关键问题是如何检查主问题给出的解的可行性，以及当解不最优时需添加什么新约束。

**问题 1**：假设从主问题的一步得到解 $x$（表示网络中存在哪些边）。写出一个线性规划，用于检查在给定网络中，从某节点 $s_d$ 到 $t_d$ 的最大边独立路径数。给出数学表述。

**问题 2**：基于问题 1，图在什么条件下是双连通的？（参考上述Menger定理的边连通版本。）

**问题 3**：设计一个程序计算需要添加到主问题的新约束。提示：问题 1 的线性规划解给出了一个流量，移除此流量（以及对应的边）将导致网络不连通。接着，可运行简单的广度优先搜索算法来检查哪些节点与 $s_d$ 连通。这将形成集合 $S$。

**问题 4**：将所有部分组合起来，描述一个割生成算法。

---

**练习 2：列生成**

以下线性规划对应网络设计问题。给定一组节点 $V$ 和边 $E$ 组成的网络、一组需求 $d \in D$（其起点/终点为 $s_d$ 和 $t_d$）及流量值 $h_d$。记 $y_e$ 为链路 $e \in E$ 的容量，其总和需最小化。我们使用路径表述，其中 $p$ 为连接 $s_d$ 和 $t_d$ 的路径，$P_d$ 是所有此类路径的集合，$x_p^d$ 表示路径 $p \in P_d$ 上的流量。

**目标函数：**

$$
\min \sum_{e \in E} y_e \tag{6.7a}
$$

**约束条件：**

$$
\sum_{p \in P_d} x_p^d \geq h_d, \quad d \in D \tag{6.7b}
$$

$$
\sum_{e \in p, p \in P_d, d \in D} x_p^d \leq y_e, \quad e \in E \tag{6.7c}
$$

$$
x_p^d \geq 0, \quad p \in P_d, \, d \in D \tag{6.7d}
$$

$$
y_e \geq 0, \quad e \in E \tag{6.7e}
$$

其中，$\lambda_d$ 和 $\pi_e$ 是对应的对偶变量。

**问题**：展示如何使用列生成方法解决上述线性规划。

以下是图片内容的翻译：

---

### 6.4 分解方法

#### 6.4.1 Dantzig-Wolfe 分解

Dantzig-Wolfe 分解是一种算法，用于求解具有特殊结构的线性规划问题。这类问题由独立的多个块和一组被称为“耦合”或“复杂化”的约束组成，这些约束将所有变量联系在一起。Dantzig-Wolfe 分解算法依赖延迟列生成，如下所示。在不失一般性的情况下，我们考虑只有两个块的方程系统。

**给定系统：**

$$
\max c_1 x_1 + c_2 x_2
$$

**约束条件：**

$$
A_1 x_1 + A_2 x_2 = b_0,  
D_1 x_1 \leq b_1,  
D_2 x_2 \leq b_2,  
x_1, x_2 \geq 0.
$$

其中，第一组约束包含 $m$ 个复杂约束，$A_i$ 是分别包含 $m_i$ 个约束的矩阵。我们可以将问题重新表述为一个具有更少约束但更多变量的问题。设 $P_i = \{x_i \,|\, D_i x_i \leq b_i\}$。问题重新表述如下：

$$
\max c_1 x_1 + c_2 x_2
$$

**约束条件：**

$$
A_1 x_1 + A_2 x_2 = b_0,  
x_i \in P_i, \, i = 1, 2.
$$

---

#### 使用 Minkowski 定理的重新表述

根据 Minkowski 定理，将 $P_1$ 的极点集表示为 $v_i^1$，极射线表示为 $r_j^1$。  
对于 $P_2$ 类似定义，问题可表述为：

$$
\max c_1 \sum_{i=1}^{k_1} \lambda_i^1 v_i^1 + c_1 \sum_{j=1}^{r_1} \theta_j^1 r_j^1 + c_2 \sum_{i=1}^{k_2} \lambda_i^2 v_i^2 + c_2 \sum_{j=1}^{r_2} \theta_j^2 r_j^2
$$

**约束条件：**

$$
A_1 \sum_{i=1}^{k_1} \lambda_i^1 v_i^1 + A_1 \sum_{j=1}^{r_1} \theta_j^1 r_j^1 + A_2 \sum_{i=1}^{k_2} \lambda_i^2 v_i^2 + A_2 \sum_{j=1}^{r_2} \theta_j^2 r_j^2 = b_0,  
\sum_{i=1}^{k_1} \lambda_i^1 = 1,  
\sum_{i=1}^{k_2} \lambda_i^2 = 1,  
\lambda_i^1, \lambda_i^2, \theta_j^1, \theta_j^2 \geq 0.
$$

这被称为主问题。与初始公式相比，该问题的约束更少（$m + 2$ 对比 $m + m_1 + m_2$），但变量数量（极点和极射线）可能非常多。

---

#### 次问题求解和简化成本计算

次问题目标：

$$
\max (c_1 - y A_1) v_i^1
$$

**约束条件：**

$$
v_i^1 \in P_1.
$$

根据次问题的最优解，有三种情况：

1. 若次问题的最优值为 $+\infty$，可生成满足 $(c_1 - y A_1) r_j^1 \geq 0$ 的极射线列。
2. 若次问题最优值有限且大于 $p_1$，可生成满足 $(c_1 - y A_1) v_i^1 - p_1 > 0$ 的极点列。
3. 若最优值有限且不大于 $p_1$，则所有简化成本为负，解为最优。

类似方法可检查变量 $\lambda_i^2$ 和 $\theta_j^2$ 的简化成本。

---

#### 算法步骤

1. 从仅包含 $m + 2$ 个极点和极射线的初始问题开始，得到主问题的可行解及对应的对偶向量 $(y, p_1, p_2)$。  
2. 构建并求解次问题：若所有简化成本为负，则解为最优；否则将新的列添加到主问题的基中，并迭代解决主问题。

---
